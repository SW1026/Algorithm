# 점화식 : i번째 수열에서, "자신보다 작은 숫자"들 중 가장 큰 수열의 길이를 구하고 +1
# d[n] : n번째 까지(n번째 원소를 포함한)의 수열 중 가장 긴 길이(max 지점에서 계속 1씩 증가해서 메모제이션한다.)

n = int(input())
a = list(map(int, input().split()))

d = [0] * n

for i in range(n):
    for j in range(i):
        # a[i]보다 작은 숫자 j중, 가장 길이가 긴 수열(j를 돌면서)을 찾는다.
        if a[i] > a[j] and d[i] < d[j]:
            # 계속 갱신해준다.
            d[i] = d[j]
    d[i] += 1

# 가장 끝 점이 모든 수열 중 가장 긴 수열은 아니다.(해당 n번째 원소를 포함한 수열에서는 가장 길겠지만)
print(max(d))


# a[i]가 50일 때, 50보다 작은 수(x들)의 d[x] 값들을 검사하여 가장 큰 d[x] 값에 +1을 해주는 것
# 좀 더 설명적인 코드
# i가 현재, j가 이전의 인덱스들 (j의 범위 : 0~i)
#if a[i] > a[j]:
#    if d[i] < d[j]:
#        d[i] = d[j]
